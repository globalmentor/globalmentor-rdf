/*
 * Copyright Â© 1996-2008 GlobalMentor, Inc. <http://www.globalmentor.com/>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.globalmentor.rdf;

import java.net.*;
import java.util.*;

import static com.globalmentor.java.Objects.*;

import com.globalmentor.model.Locales;
import com.globalmentor.net.*;
import static com.globalmentor.net.URIs.*;
import static com.globalmentor.rdf.RDF.*;
import static com.globalmentor.rdf.RDFXML.*;
import com.globalmentor.text.xml.*;
import com.globalmentor.util.*;

import org.w3c.dom.*;

/**Class that is able to construct an RDF data model from an XML-based
	RDF serialization. Each instance of an RDF processor maintains an internal
	RDF data model throughout its lifetime that is continually updated with
	every new RDF processing that occurs.
	<p>The RDF processor maintains RDF data in two separate formats: the RDF
	data model <code>RDF</code>, as well as a list of statements used to create
	the data model. The RDF data model may be replaced and its members modified,
	but these actions will not update the list of RDF statements. The RDF
	statements are only generated by the RDF processor itself as it parses
	RDF serializations, and are available to give information on the parser
	actions.</p>
	TODO If a property from a non-RDF namespace has (for example) a "resource" attribute (i.e. a property with no namespace), property resources are not correctly created and can cause endless loops when trying to analyze the namespace
@author Garret Wilson
*/
public class RDFXMLProcessor extends AbstractRDFProcessor
{

	/**Specifies a requirement for the presence of the RDF namespace in order for an RDF attribute to be recognized.
	@author Garret Wilson
	*/
	public enum NamespaceRequirement
	{
		/**Only the RDF namespace is accepted for an RDF attribute to be recognized.*/
		RDF,

		/**The RDF namespace or the <code>null</code> namespace is accepted for an RDF attribute.
		The <code>null</code> namespace is only accepted for attributes if the parent element is in the RDF namespace.
		*/
		RDF_OR_NULL,

		/**Any namespace is accepted for an RDF attribute.
		This is useful, for example, as a stop-gap measure for systems that corrupt attribute namespaces, such as Apache httpd 2.2.3 mod_dav.
		This setting is dangerous, however, as any RDF properties stored as attributes with the same local name as an RDF attribute (e.g. <code>about</code> and <code>first</code> are essentially ignored).
		*/
		ANY
	};

	/**Values for parsing attribute properties.
	@author Garret Wilson
	*/
	protected enum AttributePropertyContext
	{
		/**An attribute in the context of a resource description (<code>&lt;rdf:Description&gt;</code>).*/
		DESCRIPTION,
		/**An attribute in the context of a resource reference (<code>reference="&hellip;"</code>).*/
		REFERENCE,
		/**An attribute in the context of a property reference with only attributes and no children.*/
		EMPTY_PROPERTY,
		/**An attribute in the context of a reference short form (<code>parseType="Resource"</code>).*/
		PROPERTY_AND_NODE;
	}

	/**Whether and which namespace is required for an RDF attribute to be recognized as such.*/
	private NamespaceRequirement rdfAttributeNamespaceRequirement=NamespaceRequirement.RDF_OR_NULL;

		/**@return Whether and which namespace is required for an RDF attribute to be recognized as such.*/
		public NamespaceRequirement getRDFAttributeNamespaceRequirement() {return rdfAttributeNamespaceRequirement;}

		/**Sets whether and which namespace is required for an RDF attribute to be recognized as such.
		@param namespaceRequirement Whether and which namespace is required for an RDF attribute to be recognized as such.
		@exception NullPointerException if the given namespace requirement is <code>null</code>.
		*/
		public void setRDFAttributeNamespaceRequirement(final NamespaceRequirement namespaceRequirement) {this.rdfAttributeNamespaceRequirement=checkInstance(namespaceRequirement, "Namespace requirement cannot be null.");}

	/**Default constructor.*/
	public RDFXMLProcessor()
	{
		super();  //construct parent base class
	}

	/**Constructor that specifies an existing data model to continue filling.
	@param newRDF The RDF data model to use.
	*/
	public RDFXMLProcessor(final RDF newRDF)
	{
		super(newRDF);  //construct the parent class
	}

	/**Processes RDF serialized in an XML document. Processes data contained in
		every <code>&lt;rdf:RDF&gt;</code> data island.
	@param document The XML document that might contain RDF data.
	@param baseURI The base URI, or <code>null</code> if the base URI is not
		known.
	@return The RDF data model resulting from this processing and any previous
		processing.
	@exception URISyntaxException Thrown if a URI is syntactically incorrect.
	*/
	public RDF processRDF(final Document document, final URI baseURI) throws URISyntaxException
	{
		setBaseURI(baseURI);  //set the base URI
		return processRDF(document); //process the data in the document
	}

	/**Processes RDF serialized in an XML document. Processes data contained in
		every <code>&lt;rdf:RDF&gt;</code> data island. Whatever base URI has been
		set is unchanged.
	@param document The XML document that might contain RDF data.
	@return The RDF data model resulting from this processing and any previous
		processing.
	@exception URISyntaxException Thrown if a URI is syntactically incorrect.
	*/
	public RDF processRDF(final Document document) throws URISyntaxException
	{
		return processRDF(document.getDocumentElement()); //process the data in the document element
	}

	/**Processes RDF serialized in an XML document. Searches the given element and
		all its children, processing data contained in every
		<code>&lt;rdf:RDF&gt;</code> data island.
	@param element The XML element that might contain RDF data.
	@param baseURI The base URI, or <code>null</code> if the base URI is not
		known.
	@return The RDF data model resulting from this processing and any previous
		processing.
	@exception URISyntaxException Thrown if a URI is syntactically incorrect.
	*/
	public RDF processRDF(final Element element, final URI baseURI) throws URISyntaxException
	{
		setBaseURI(baseURI);  //set the base URI
		return processRDF(element);	//process the element
	}

	/**Processes RDF serialized in an XML document. Searches the given element
		and all its children, processing data contained in every
		<code>&lt;rdf:RDF&gt;</code> data island. Whatever base URI has been
		set is unchanged.
	@param element The XML element that might contain RDF data.
	@return The RDF data model resulting from this processing and any previous
		processing.
	@exception URISyntaxException Thrown if a URI is syntactically incorrect.
	*/
	public RDF processRDF(final Element element) throws URISyntaxException
	{
		reset();	//make sure we don't have temporary data left over from last time
		processRDFIslands(element);	//process any internal RDF islands
		createResources();	//create all proxied resources in the statements we gathered
		processStatements();	//process all the statements and assign resources to properties
		reset();	//release all our references temporary resource proxies
		return getRDF();  //return the RDF data collected
	}

	/**Processes an RDF resource serialized in the provided XML document.
	Whatever base URI has been set is unchanged.
	@param element The XML element that might contain RDF data.
	@return The RDF data model resulting from this processing and any previous processing.
	@exception URISyntaxException Thrown if a URI is syntactically incorrect.
	*/
	public RDFResource processRDFResource(final Element element) throws URISyntaxException
	{
		reset();	//make sure we don't have temporary data left over from last time
		final Resource resource=processResource(element);	//process the given RDF resource
		final RDFResource rdfResource=createResources(resource);	//create all proxied resources in the statements we gathered, and get the RDF resource the element represents
		processStatements();	//process all the statements and assign resources to properties
		reset();	//release all our references temporary resource proxies
		return rdfResource;  //return the RDF resource the element represents
}

	/**Processes RDF serialized in an XML document. Searches the given element
		and all its children, processing data contained in every
		<code>&lt;rdf:RDF&gt;</code> data island. Whatever base URI has been
		set is unchanged.
	@param element The XML element that might contain RDF data.
	@return The RDF data model resulting from this processing and any previous
		processing.
	@exception URISyntaxException Thrown if a URI is syntactically incorrect.
	*/
	protected RDF processRDFIslands(final Element element) throws URISyntaxException
	{
		if(RDF_NAMESPACE_URI.toString().equals(element.getNamespaceURI()) //if this element is in the RDF namespace TODO fix better
			  && ELEMENT_RDF.equals(element.getLocalName())) //if this element indicates that the children are RDF
		{
			final NodeList childNodeList=element.getChildNodes(); //get a list of child nodes
			for(int i=0; i<childNodeList.getLength(); ++i)  //look at each child node
			{
				final Node childNode=childNodeList.item(i); //get a reference to this child node
				if(childNode.getNodeType()==Node.ELEMENT_NODE) //if this is an element
				{
					processResource((Element)childNode);  //parse the contents of the RDF container element
				}
			}
		}
		else  //if this is a normal, non-RDF node
		{
			final NodeList childNodeList=element.getChildNodes(); //get a list of child nodes
			for(int i=0; i<childNodeList.getLength(); ++i)  //look at each child node
			{
				final Node childNode=childNodeList.item(i); //get a reference to this child node
				if(childNode.getNodeType()==Node.ELEMENT_NODE) //if this is an element
				{
					processRDFIslands((Element)childNode);  //parse the contents of the element, not knowing if this is an RDF element or not
				}
			}
		}
		return getRDF();  //return the RDF data collected
	}

	/**Processes the given element as representing an RDF resource.
	@param element The XML element that represents the RDF resource.
	@return An object identifying the resource the XML element represents.
	@exception URISyntaxException Thrown if a URI is syntactically incorrect.
	*/
	protected Resource processResource(final Element element) throws URISyntaxException
	{
		final URI elementNamespaceURI=element.getNamespaceURI()!=null ? new URI(element.getNamespaceURI()) : null; //get the element's namespace, or null if the element has no namespace
		final String elementLocalName=element.getLocalName(); //get the element's local name
		//TODO what do we do if <rdf:RDF> occurs inside <rdf:RDF>?
		final String referenceURIValue=getRDFAttribute(element, ATTRIBUTE_ABOUT); //get the reference URI attribute value, if there is one
		final String nodeIDValue=getRDFAttribute(element, ATTRIBUTE_NODE_ID);	//get the node ID attribute value, if there is one
		final String anchorID=getRDFAttribute(element, ATTRIBUTE_ID); //get the anchor ID if there is one
	  assert referenceURIValue==null || anchorID==null : "Resource cannot have both reference URI "+referenceURIValue+" and anchor ID "+anchorID+"."; //TODO change to an actual RDF error
		assert referenceURIValue==null || nodeIDValue==null : "Resource cannot have both reference URI "+referenceURIValue+" and node ID "+nodeIDValue+"."; //TODO change to an actual RDF error
		final URI referenceURI;  //we'll determine the reference URI from the rdf:about or rdf:ID attribute
		if(referenceURIValue!=null) //if there is a reference URI
		{
			referenceURI=resolveURI(element, new URI(referenceURIValue));  //resolve the reference URI to the base URI
		}
		else if(anchorID!=null)  //if there is an anchor ID
		{
			referenceURI=new URI(XMLBase.getBaseURI(element, getBaseURI()).toString()+FRAGMENT_SEPARATOR+anchorID);  //create a reference URI from the document base URI and the anchor ID	//TODO make better with new URI methods
		}
		else  //if there is neither a resource ID nor an anchor ID
		{
			referenceURI=null;  //this is a blank node
		}
		final Resource resource;	//we'll create either an RDF resource, if we know the type, or a proxy for the resource
		if(referenceURI!=null)	//if we have a reference URI for the resouce
		{
			resource=getResourceProxy(referenceURI);	//create a resource proxy from the reference URI, or use one already available for the reference URI
		}
		else	//if there is no reference URI
		{
		//TODO del Debug.trace("there is no reference URI; getting proxy");
			resource=getResourceProxy(nodeIDValue!=null ? nodeIDValue : generateNodeID());	//retrieve or create a resource proxy from the node ID, generating our own node ID if there was none given
		}
			//if this is not an <rdf:Description> element, the element name gives its type, so add that type to the resource
		if(!RDF_NAMESPACE_URI.equals(elementNamespaceURI) || !ELEMENT_DESCRIPTION.equals(elementLocalName))
		{
			final RDFResource typeProperty=getRDF().locateResource(RDF_NAMESPACE_URI, TYPE_PROPERTY_NAME); //get an rdf:type resource
			final RDFResource typePropertyValue=getRDF().locateResource(elementNamespaceURI, elementLocalName);	//locate the resource representing the type value
		//TODO del Debug.trace("adding type statement for the resource, with type property", typeProperty, "and type property value", typePropertyValue);
				//add a statement in the form, {resource proxy, rdf:type resource, type value resource}
			addStatement(new DefaultStatement(resource, typeProperty, typePropertyValue));
		}
		processAttributeProperties(resource, element, AttributePropertyContext.DESCRIPTION);  //parse the attributes for the resource description
	//TODO del Debug.trace("ready to process child element properties");
		processChildElementProperties(resource, element);	//parse the child elements as properties
	//TODO del Debug.trace("ready to return property value resource", resource, "type", resource.getClass());
		return resource;  //return the resource or resource proxy we created
	}

	/**Parses the child elements of the given element and assign them as
	  properties to the given resource.
	@param resource The object that represents the resource to which
		child element properties should be added.
	@param element The element that contains the attributes to be considered
		properties.
	@exception URISyntaxException Thrown if a URI is syntactically incorrect.
	*/
	protected void processChildElementProperties(final Resource resource, final Element element) throws URISyntaxException
	{
		int memberCount=0; //show that we haven't found any container members, yet
		final NodeList childNodeList=element.getChildNodes(); //get a list of child nodes
		for(int i=0; i<childNodeList.getLength(); ++i)  //look at each child node
		{
			final Node childNode=childNodeList.item(i); //get a reference to this child node
			if(childNode.getNodeType()==Node.ELEMENT_NODE) //if this is an element
			{
				final Resource property=processProperty(resource, (Element)childNode, memberCount);  //parse the element representing an RDF property
					//if this is an rdf:_X property (originally serialized as rdf:li)
				if(RDFResources.isContainerMemberPropertyReference(property.getURI()))
				{
					++memberCount;  //show that we have another member
				}
			}
		}
	}

	/**Parses the attributes of the given element and assign them as properties
	  to the given resource. Special RDF properties such as <code>rdf:about</code>
		are ignored.
	@param resource The object that represents the resource to which attribute
		properties should be added.
	@param element The element that contains the attributes to be considered
		properties.
	@param context Whether the attributes are part of a resource description, a resource reference,
		a reference to a blank node resource in short form, or the creation of a blank node from
		an empty property element.
	@exception URISyntaxException Thrown if an RDF URI is syntactically incorrect.
	*/
	protected void processAttributeProperties(final Resource resource, final Element element, final AttributePropertyContext context) throws URISyntaxException
	{
			//TODO make sure we make sure there is no reference or node ID attributes for AttributePropertyContext.EMPTY_PROPERTY
		final URI elementNamespaceURI=element.getNamespaceURI()!=null ? new URI(element.getNamespaceURI()) : null; //get the element's namespace, or null if there is no namespace URI
		final NamedNodeMap attributeNodeMap=element.getAttributes();  //get a map of the attributes
		for(int i=attributeNodeMap.getLength()-1; i>=0; --i)  //look at each of the attributes
		{
			final Attr attribute=(Attr)attributeNodeMap.item(i);  //get a reference to this attribute
		  final URI attributeNamespaceURI=attribute.getNamespaceURI()!=null ? new URI(attribute.getNamespaceURI()) : null; //get the attribute's namespace URI, or null if it has no namespace URI
			final String attributePrefix=attribute.getPrefix(); //get the attribute's prefix
		  final String attributeLocalName=attribute.getLocalName(); //get the attribute's local name
		  final String attributeValue=attribute.getValue(); //get the attribute's value
				//ignore attributes with the "xmlns" prefix or in the xmlns namespace
			if(XML.XMLNS_NAMESPACE_PREFIX.equals(attributePrefix) || XML.XMLNS_NAMESPACE_URI.equals(attributeNamespaceURI))
			{
				continue;
			}
				//process attributes with the "xml" prefix (or in the xml namespace) specially
			else if(XML.XML_NAMESPACE_PREFIX.equals(attributePrefix) || XML.XML_NAMESPACE_URI.equals(attributeNamespaceURI))
			{
					//TODO add support for xml:lang
				continue;
			}
			  //ignore the rdf:about attribute in descriptions, disallow it in references
			else if(isRDFAttribute(ATTRIBUTE_ABOUT, elementNamespaceURI, attributeNamespaceURI, attributeLocalName))
			{
				switch(context)	//only allow this attribute in certain contexts
				{
					case REFERENCE:	//rdf:about isn't allowed in a reference
					case EMPTY_PROPERTY:	//rdf:about isn't allowed in an empty property element
					case PROPERTY_AND_NODE: 	//rdf:about isn't allowed in parseType="Resource"
						throw new IllegalStateException("rdf:about attribute is not allowed in a resource reference."); //TODO fix with real exceptions
					case DESCRIPTION:	//ignore rdf:about in descriptions
					default:
						continue;
				}
			}
			  //ignore the rdf:ID attribute in descriptions, disallow it in references
			else if(isRDFAttribute(ATTRIBUTE_ID, elementNamespaceURI, attributeNamespaceURI, attributeLocalName))
			{
				switch(context)	//only allow this attribute in certain contexts
				{
					case REFERENCE:	//rdf:ID isn't allowed in a reference
					case EMPTY_PROPERTY:	//rdf:ID isn't allowed in an empty property element
					case PROPERTY_AND_NODE: 	//rdf:ID isn't allowed in parseType="Resource"
						throw new IllegalStateException("rdf:ID attribute is not allowed in a resource reference."); //TODO fix with real exceptions
					case DESCRIPTION:	//ignore rdf:ID in descriptions
					default:
						continue;
				}
			}
				//ignore the rdf:nodeID attribute in descriptions and references
			else if(isRDFAttribute(ATTRIBUTE_NODE_ID, elementNamespaceURI, attributeNamespaceURI, attributeLocalName))
			{
				switch(context)	//only allow this attribute in certain contexts
				{
					case PROPERTY_AND_NODE: 	//rdf:nodeID isn't allowed in parseType="Resource" TODO make sure this is correct
						throw new IllegalStateException("rdf:nodeID attribute is not allowed in blank node reference short form."); //TODO fix with real exceptions
					case REFERENCE:	//ignore rdf:nodeID in references
					case EMPTY_PROPERTY:	//ignore rdf:nodeID in empty property elements TODO make sure this is correct
					case DESCRIPTION:	//ignore rdf:nodeID in descriptions
					default:
						continue;
				}
			}
			  //ignore the rdf:parseType attribute in references, disallow it in descriptions
			else if(isRDFAttribute(ATTRIBUTE_PARSE_TYPE, elementNamespaceURI, attributeNamespaceURI, attributeLocalName))
			{
				switch(context)	//only allow this attribute in certain contexts
				{
					case DESCRIPTION:	//rdf:parseType isn't allowed in a description
					case REFERENCE:	//rdf:parseType isn't allowed in references
					case EMPTY_PROPERTY:	//rdf:parseType isn't allowed in an empty property element
						throw new IllegalStateException("rdf:parseType attribute is not allowed in a resource description."); //TODO fix with real exceptions
					case PROPERTY_AND_NODE: 	//ignore rdf:parseType in the property-and-node context (that's the attribute that defined this context, after all)
					default:
						continue;
				}
			}
			  //ignore the rdf:resource attribute in reference, disallow it in descriptions
			else if(isRDFAttribute(ATTRIBUTE_RESOURCE, elementNamespaceURI, attributeNamespaceURI, attributeLocalName))
			{
				switch(context)	//only allow this attribute in certain contexts
				{
					case DESCRIPTION:	//rdf:resource isn't allowed in descriptions
					case EMPTY_PROPERTY:	//rdf:resource isn't allowed in an empty property element
					case PROPERTY_AND_NODE: 	//rdf:ID isn't allowed in parseType="Resource"
						throw new IllegalStateException("rdf:resource attribute is not allowed in a resource reference."); //TODO fix with real exceptions
					case REFERENCE:	//rdf:resource isn't allowed in a reference
					default:
						continue;
				}
			}
			else	//for all other attributes
			{
				switch(context)	//only allow this attribute in certain contexts
				{
					case REFERENCE:	//normal attributes are allowed for a normal reference
					case PROPERTY_AND_NODE: 	//normal attributes isn't allowed in the parseType="Resource" context
						throw new IllegalStateException(attribute.getName()+" attribute is not allowed in a property-and-node context."); //TODO fix with real exceptions
					default:
						{
							final RDFResource property=getRDF().locateResource(attributeNamespaceURI, attributeLocalName);	//locate a resource for this attribute property
							final RDFLiteral objectLiteral=new RDFPlainLiteral(attributeValue);	//create a literal for the object
								//add a statement in the form, {resource, property, object literal}
							addStatement(new DefaultStatement(resource, property, objectLiteral));
						}
						break;
				}
			}
		}
	}

	/**Processes the given element as representing an RDF property.
	@param resource The object that represents the resource to which the property
		should be added.
	@param element The XML element that represents the RDF property.
	@param memberCount The number of container member items (represented by
		<code>rdf:li</code>) the resource already contains.
	@return The resource that represents the processed property, the predicate
		of the added statement.
	@exception URISyntaxException Thrown if an RDF URI is syntactically incorrect.
	*/
	public Resource processProperty(final Resource resource, final Element element, final int memberCount) throws URISyntaxException
	{
		final URI elementNamespaceURI=element.getNamespaceURI()!=null ? new URI(element.getNamespaceURI()) : null; //get the element's namespace, or null if there is no namespace URI
		final String elementLocalName=element.getLocalName(); //get the element's local name
//Debug.trace("processing property with XML element namespace: ", elementNamespaceURI, "local name", elementLocalName);
		final String propertyLocalName;	//if this is an rdf:li property, we'll convert it to rdf_X, where X represents the member count plus one
		if(RDF_NAMESPACE_URI.equals(elementNamespaceURI) && LI_PROPERTY_NAME.equals(elementLocalName)) //if this is an rdf:li property
		{
			propertyLocalName=CONTAINER_MEMBER_PREFIX+(memberCount+1); //create a local name in the form "_X", where X is the member count plus one
		}
		else	//if this is *not* an rdf:li property, it's a normal property
		{
			propertyLocalName=elementLocalName;	//use the element's local name normally in forming the property reference URI
		}
		final RDFResource propertyResource=getRDF().locateResource(elementNamespaceURI, propertyLocalName); //get a resource from the element name
		final Object propertyValue;  //we'll assign the property value to this variable---either a resource or a literal
		final String parseType=getRDFAttribute(element, ATTRIBUTE_PARSE_TYPE); //get the parse type, if there is one
		if(COLLECTION_PARSE_TYPE.equals(parseType))	//if this is a collection
		{
			//TODO we should make sure there are no other attributes
			Resource firstItemListResource=null;	//we haven't created the first item list resource, yet
			Resource lastItemListResource=null;	//we haven't created the last item list resource, yet
			final RDFResource typeProperty=getRDF().locateResource(RDF_NAMESPACE_URI, TYPE_PROPERTY_NAME); //get an rdf:type resource
			final RDFResource listClassResource=getRDF().locateResource(RDF_NAMESPACE_URI, LIST_CLASS_NAME);	//locate the resource representing the rdf:list class
				//parse the child elements
			final NodeList childNodeList=element.getChildNodes(); //get a list of child nodes
			for(int i=0; i<childNodeList.getLength(); ++i)  //look at each child node
			{
				final Node childNode=childNodeList.item(i); //get a reference to this child node
				if(childNode.getNodeType()==Node.ELEMENT_NODE) //if this is an element
				{
					final Resource elementValue=processResource((Element)childNode); //process the child element as an RDF resource
					final Resource listResource=getResourceProxy(generateNodeID());	//create a new list resource proxy to represent this item in the collection
						//add a statement in the form, {list, rdf:type, rdf:list}
					addStatement(new DefaultStatement(listResource, typeProperty, listClassResource));
					final Resource firstProperty=getRDF().locateResource(RDF_NAMESPACE_URI, FIRST_PROPERTY_NAME);	//get a resource representing the rdf:first property
						//add a statement setting the list's rdf:first property to the new element
					addStatement(new DefaultStatement(listResource, firstProperty, elementValue));
					if(firstItemListResource==null)	//if this is the first list item
					{
						firstItemListResource=listResource;	//show that we just created a list resource
					}
					else if(lastItemListResource!=null)	//if this is not the first item, there should have been a previous list item (this check is redundant)
					{
						final Resource restProperty=getRDF().locateResource(RDF_NAMESPACE_URI, REST_PROPERTY_NAME);	//get a resource representing the rdf:rest property
							//add a statement setting the previous list's rdf:rest property to the new list
						addStatement(new DefaultStatement(lastItemListResource, restProperty, listResource));
					}
					lastItemListResource=listResource;	//save this list resource for the next time around, in case there are other list items
				}
			}
			final RDFListResource nilListResource=new RDFListResource(NIL_RESOURCE_URI);	//create a list resource representing the rdf:nil resource; don't use an existing rdf:nil list resource, because the reference URI may need to change when the list is modified
				//add a statement in the form, {nil list, rdf:type, rdf:list}
			addStatement(new DefaultStatement(nilListResource, typeProperty, listClassResource));
			if(lastItemListResource!=null)	//if there was a last item
			{
				final Resource restProperty=getRDF().locateResource(RDF_NAMESPACE_URI, REST_PROPERTY_NAME);	//get a resource representing the rdf:rest property
					//add a statement setting the last list's rdf:rest property to the the rdf:nil list
				addStatement(new DefaultStatement(lastItemListResource, restProperty, nilListResource));
			}
			else if(firstItemListResource==null)	//if we didn't create any list items (logically this check is redundant, because if there is no last resource there is also no first resource)
			{
				firstItemListResource=nilListResource;	//the first list item is the rdf:nil list, because there list contained no items
			}
			propertyValue=firstItemListResource;	//the first list item will be the first list item, whether it is a node representing a resource or the rdf:nil list we created for an empty list
		}
		else if(RESOURCE_PARSE_TYPE.equals(parseType))	//if this is a resource as a property-and-node
		{
			propertyValue=getResourceProxy(generateNodeID());	//retrieve or create a new resource proxy with our own generated node ID, as the node is completely anonymous
			processAttributeProperties((Resource)propertyValue, element, AttributePropertyContext.PROPERTY_AND_NODE);  //parse the property attributes, which will simply create errors if there are any unexpected attributes
			processChildElementProperties((Resource)propertyValue, element);	//parse the child elements as properties
		}
		else if(LITERAL_PARSE_TYPE.equals(parseType))	//if this is an XMLLiteral
		{
			//TODO process the attributes to make sure there are no unexpected attributes
			final Document document=XML.createDocument(element);	//create a new document from a copy of the given element
			//TODO do we want to ensure namespace declarations?
			final Element documentElement=document.getDocumentElement();	//get a reference to the document element
			final DocumentFragment documentFragment=XML.extractChildren(documentElement);	//extract the children of the document element to a document fragment TODO important probably reset the owner document, so that this won't keep the entire original document tree around
			propertyValue=new RDFXMLLiteral(documentFragment);	//create an XML literal containing the document fragment, which now contains a copy of the information of the XML tree below the given element
		}
		else	//by default assume that we're parsing a resource as the property value
		{
//Debug.trace("we must be parsing a resource as the property value");
			final String referenceURIValue=getRDFAttribute(element, ATTRIBUTE_RESOURCE); //get the reference URI of the referenced resource, if there is one
			final String nodeIDValue=getRDFAttribute(element, ATTRIBUTE_NODE_ID);	//get the node ID attribute value, if there is one
			assert referenceURIValue==null || nodeIDValue==null : "Resource cannot have both reference URI "+referenceURIValue+" and node ID "+nodeIDValue+"."; //TODO change to an actual RDF error
			if(referenceURIValue!=null || nodeIDValue!=null) //if there is a reference URI or a node ID, this is a reference to another node
			{
				final ResourceProxy resourceProxy;	//we'll create a stand-in object for the resource
				if(referenceURIValue!=null)	//if we have a reference URI for the resouce
				{
					final URI referenceURI=resolveURI(element, new URI(referenceURIValue));  //resolve the reference URI to the base URI
					propertyValue=getResourceProxy(referenceURI);	//create a resource proxy from the reference URI, or use one already available for the reference URI
				}
				else	//if there is no reference URI
				{
					propertyValue=getResourceProxy(nodeIDValue!=null ? nodeIDValue : generateNodeID());	//retrieve or create a resource proxy from the node ID, generating our own node ID if there was none given
				}
//Debug.trace("ready to process attributes");
				processAttributeProperties((Resource)propertyValue, element, AttributePropertyContext.REFERENCE);  //parse the property attributes, assigning them to the property value
			}
			else if(element.getChildNodes().getLength()==0 && element.getAttributes().getLength()!=0) //if there are no child elements but there are attributes, this is a blank node
			{
				propertyValue=getResourceProxy(generateNodeID());	//retrieve or create a new resource proxy with our own generated node ID, as the node is completely anonymous
				processAttributeProperties((Resource)propertyValue, element, AttributePropertyContext.EMPTY_PROPERTY);  //parse the property attributes, assigning them to the property value
			}
			else  //if there is no reference URI or node ID, and there are children, there is either a normal property description below, or a literal
			{
			//TODO del Debug.trace("seems to be a normal property description; ready to process its contents");
				//TODO we should make sure there are no attributes
				propertyValue=processPropertyValueContents(element);	//process the contents of the element as a normal property value
			}
		}
		if(propertyValue instanceof Resource)	//if we found a resource for the property value
		{
		//TODO del Debug.trace("we found a resource property value:", propertyValue, "of type", propertyValue.getClass(), "creating a statement for subject resource", resource);
				//add a statement in the form, {resource/resource proxy, property resource, resource/resource proxy value}
			addStatement(new DefaultStatement(resource, propertyResource, (Resource)propertyValue));
		}
		else if(propertyValue instanceof RDFLiteral)	//if we found a literal value for the property value
		{
				//add a statement in the form, {resource/resource proxy, property resource, literal value}
			addStatement(new DefaultStatement(resource, propertyResource, (RDFLiteral)propertyValue));
		}
		else	//we should only have found a resource (or resource proxy) or a literal
		{
			throw new AssertionError("Logical error: expected resource or literal for object, somehow created "+propertyValue.getClass());
		}
		return propertyResource;	//return the resource that represents the property we processed
	}

	/**Processes the contents of a property element as normal property contents.
	Nodes that are not elements are not capable of determining RDF typed literal datatypes and language tags
	@param propertyNode The node the contents of which represents the property value.
	@return An object representing the property value, such as an {@link RDFLiteral} or a {@link Resource} (which may be a proxy resource).
	@exception URISyntaxException Thrown if an RDF URI is syntactically incorrect.
	*/
	public Object processPropertyValueContents(final Node propertyNode) throws URISyntaxException
	{
		Element childElement=null; //show that we haven't found any child elements, yet
			//parse the child elements
		final NodeList childNodeList=propertyNode.getChildNodes(); //get a list of child nodes
		for(int i=0; i<childNodeList.getLength(); ++i)  //look at each child node
		{
			final Node childNode=childNodeList.item(i); //get a reference to this child node
			if(childNode.getNodeType()==Node.ELEMENT_NODE) //if this is an element
			{
				if(childElement==null)  //if we haven't already found a child element
				{
					childElement=(Element)childNode;  //cast the child node to an element
				}
				else if(childElement!=null)  //if we've already found a child element
				{
					Debug.warn("Only one property value allowed for property element "+propertyNode.getNodeName()); //TODO with real error handling
				}
			}
		}
		if(childElement!=null)  //if we found a child element for the property value
		{
		//TODO del Debug.trace("found child element; ready to process as resource");
			return processResource(childElement); //process the child element as an RDF resource, the value of the property in this case
		}
		else  //if we didn't find any child elements, the content is a literal
		{
			final String childText=XML.getText(propertyNode, true);	//retrieve the child text
			final String datatype=propertyNode instanceof Element ? getRDFAttribute((Element)propertyNode, ATTRIBUTE_DATATYPE) : null; //get the datatype, if there is one TODO check elsewhere to make sure a datatype isn't given for non-literal content
			if(datatype!=null)	//if a datatype is present
			{
				return getRDF().createTypedLiteral(childText, new URI(datatype));	//create a typed literal from the typed literal text
			}
			else	//if a datatype is not present, this is a plain literal
			{
					//get the xml:lang language tag, if there is one
				final String languageTag=propertyNode instanceof Element ? XML.getDefinedAttributeNS((Element)propertyNode, XML.XML_NAMESPACE_URI.toString(), XML.ATTRIBUTE_LANG) : null;
					//create a locale for the language if there is a language tag
				final Locale languageLocale=languageTag!=null ? Locales.createLocale(languageTag) : null;
				return new RDFPlainLiteral(childText, languageLocale);  //create a literal from the element's text, noting the specified language if any
			}
		}
	}

	/**Determines if an element attribute is an RDF attribute, recognizing
		either prefixed or non-prefixed attributes.
	@param rdfAttributeLocalName The RDF attribute name to check for.
	@param elementNamespaceURI The namespace of the element to which the
		attribute belongs.
	@param attributeNamespaceURI namespace of the RDF attribute.
	@param attributeLocalName The local name of the RDF attribute.
	@return <code>true</code> if this is the specified RDF attribute.
	*/
	protected boolean isRDFAttribute(final String rdfAttributeLocalName, final URI elementNamespaceURI, final URI attributeNamespaceURI, final String attributeLocalName)
	{
		if(rdfAttributeLocalName.equals(attributeLocalName))	//if the attribute has the correct local name
		{
			if(RDF_NAMESPACE_URI.equals(attributeNamespaceURI))	//if the attribute is in the RDF namespace
			{
				return true;	//show that this is the expected RDF attribute
			}
			switch(getRDFAttributeNamespaceRequirement())	//see if the RDF attribute namespace is required
			{
				case RDF_OR_NULL:
					 if(attributeNamespaceURI==null && RDF_NAMESPACE_URI.equals(elementNamespaceURI))	//accept the null namespace if the element is in the RDF namespace
					 {
						 return true;
					 }
					 break;
				case ANY:
					return true;	//the namespace doesn't matter
			}
		}
		return false;	//show that this attribute is not the RDF attribute expected
	}

	/**Retrieves an RDF attribute from an element, if it exists, recognizing
		either prefixed or non-prefixed attributes. If the non-prefixed form is
		used, a warning is generated.
		It is assumed that this method will only be called once for a particular
		attribute, as each call could produce another warning.
	@param element The element being checked for attributes.
	@param attributeLocalName The local name of the RDF attribute to check for.
	@return The specified RDF attribute, or <code>null</code> if no such attribute was found.
	*/
	protected String getRDFAttribute(final Element element, final String attributeLocalName)
	{
		if(element.hasAttributeNS(RDF_NAMESPACE_URI.toString(), attributeLocalName))  //if there is a prefixed attribute value
		{
		  return element.getAttributeNS(RDF_NAMESPACE_URI.toString(), attributeLocalName); //get the prefixed attribute value
		}
		switch(getRDFAttributeNamespaceRequirement())	//see if the RDF attribute namespace is required
		{
			case RDF_OR_NULL:
				if(RDF_NAMESPACE_URI.toString().equals(element.getNamespaceURI()) && element.hasAttributeNS(null, attributeLocalName)) //if there is a non-prefixed attribute value
				{
					Debug.warn("Non-prefixed rdf:"+attributeLocalName+" attribute deprecated."); //TODO put in a real warning
				  return element.getAttributeNS(null, attributeLocalName); //return the non-prefixed attribute value
				}
			case ANY:
				final NamedNodeMap attributes=element.getAttributes();	//get the attributes
				for(int i=attributes.getLength()-1; i>=0; --i)	//look at all the attributes
				{
					final Node attribute=attributes.item(i);	//get this attribute
					if(attributeLocalName.equals(attribute.getLocalName()))	//if this attribute has the correct local name
					{
						return attribute.getNodeValue();	//return the value of the attribute
					}
				}
				break;
		}
		return null;  //show that the RDF attribute is not available
	}

	/**Creates a URI by resolving the given URI relative to the base URI of the provided element, taking into account the given base URI of the document.
	URIs are resolved according to RDF/XML processing rules.
	@param element The element for which a base URI should be determined.
	@param uri The URI to resolve.
	@return A URI resolved to the in-scope base URI of the given element.
	@exception NullPointerException if the given element and/or URI is <code>null</code>.
	@exception URISyntaxException Thrown if the constructed URI is invalid.
	@see XBase
	@see #resolveURI(URI, URI)
	*/
	protected URI resolveURI(final Element element, final URI uri) throws URISyntaxException
	{
		final URI baseURI=XMLBase.getBaseURI(element, getBaseURI());  //get the base URI of the element
		return baseURI!=null ? resolveURI(baseURI, uri) : uri;	//resolve the given URI to the base URI we determine
	}

	/**Resolves a URI against a base URI according to RDF/XML processing rules.
	Significantly, the emptry string is appended to the given base URI.
	@param baseURI The in-scope base URI against which the URI should be resolved.
	@param uri The URI to resolve.
	@return A URI resolved to the given base URI according to RDF/XML processing rules.
	@exception NullPointerException if the given element and/or URI is <code>null</code>.
	@see <a href="http://www.w3.org/TR/2003/PR-rdf-syntax-grammar-20031215/#section-baseURIs">RDF/XML Syntax Specification (Revised) 5.3 Resolving URIs</a>
	 */
	public static URI resolveURI(final URI baseURI, final URI uri)
	{
		checkInstance(baseURI, "Base URI cannot be null.");
		if(isPathURI(uri))	//if the given URI is only a path
		{
			final String path=uri.getPath();	//get the path of the URI
			if(path.length()==0)	//if this URI is ""
			{
				return baseURI;	//return the base URI
			}
		}
		return baseURI.resolve(uri);	//resolve the URI against the base URI normally
	}

}