package com.garretwilson.rdf;

import java.net.URI;
import java.net.URISyntaxException;
import java.util.*;
import com.garretwilson.net.URLConstants;
import com.garretwilson.text.xml.XMLUtilities;
import com.garretwilson.util.Debug;
import com.garretwilson.util.NameValuePair;
import org.w3c.dom.*;

/**Base class for RDF processors.
	Each instance of an RDF processor maintains an internal
	RDF data model throughout its lifetime that is continually updated with
	every new RDF processing that occurs.
	<p>The RDF processor maintains RDF data in two separate formats: the RDF
	data model <code>RDF</code>, as well as a list of statements used to create
	the data model. The RDF data model may be replaced and its members modified,
	but these actions will not update the list of RDF statements. The RDF
	statements are only generated by the RDF processor itself as it parses
	RDF serializations, and are available to give information on the parser
	actions.</p>
@author Garret Wilson
*/
public abstract class AbstractRDFProcessor implements RDFConstants
{

	//constants for parseAttributeProperties()
	protected static final int DESCRIPTION_CONTEXT=1;
	protected static final int REFERENCE_CONTEXT=2;

	/**The RDF data model that is filled by the processor.*/
	private RDF rdf;

		/**@return The RDF data model being constructed by the RDF processor.*/
		public RDF getRDF() {return rdf;}

		/**Sets the RDF data model and resets the statement list.
		@param newRDF The RDF data model to use.
		*/
		public void setRDF(final RDF newRDF)
		{
			rdf=newRDF; //set the RDF data model
			statementList.clear();  //clear the list of statements
		}

	/**The base URI of the RDF being processed, or <code>null</code> if
		no base URI was specified.
	*/
	private URI baseURI=null;

		/**Sets the base URI for the RDF being processed.
		@param newBaseURI The base URI of the RDF being processed, or
			<code>null</code> if no base URI was specified.
		*/
		protected void setBaseURI(final URI newBaseURI)
		{
			baseURI=newBaseURI; //set the base URI
		}

		/**@return The base URI of the RDF being processed, or "online:" if no
			base URI is known.
		*/
		protected URI getBaseURI()
		{
			try
			{
				return baseURI!=null ? baseURI : new URI("online:/");	//return the base URI if we know it	//G***use a constant
			}
			catch (URISyntaxException e)
			{
				return null;	//G***fix
			} 
		}

	/**The list of all statements used to create the resources.*/
	private final List statementList=new ArrayList(); //G***use a map-based list

	/**Adds a statement to the list of statements. The statement is also
		interpreted and processed, updating the RDF data model.
		If an equivalent statement already exists in the list, no action occurs.
	@param statement The statement to add.
	*/
	protected void addStatement(final Statement statement)
	{
		Debug.trace("adding statement: ", statement); //G***del
//G***del Debug.traceStack();		  //G***del
		//G***convert to a map-based list and create a Statement.equals() method
		if(!statementList.contains(statement)) //if the list doesn't already contain the statement
		{
		  statementList.add(statement); //add the statement to the list
			statement.getSubject().addProperty(statement.getPredicate(), statement.getObject());  //actually update the subject in the data model
		}
	}

	/**Creates a new statement from existing data and adds that statement to the
		lists of statements. The statement is also interpreted and processed,
		updating the RDF data model.
		If an equivalent statement already exists in the list, no action occurs.
	@param predicate The predicate of the statement.
	@param subject The subject of the statement.
	@param object The object of the statement.
	*/
	protected void addStatement(final RDFResource predicate, final RDFResource subject, final RDFObject object)
	{
		addStatement(new Statement(predicate, subject, object)); //create a statement and add it to our data model
	}

	/**@return A read-only iterator of all statements collected and processed by
		the processor.
	*/
	public Iterator getStatementIterator()
	{
		return Collections.unmodifiableList(statementList).iterator();  //create an unmodifiable list from the statement list and return an iterator to it
	}

	/**Default constructor.*/
	public AbstractRDFProcessor()
	{
		this(new RDF());  //create an RDF data model to use
	}

	/**Constructor that specifies an existing data model to continue filling.
	@param newRDF The RDF data model to use.
	*/
	public AbstractRDFProcessor(final RDF newRDF)
	{
		setRDF(newRDF);  //set the RDF data model
	}
}