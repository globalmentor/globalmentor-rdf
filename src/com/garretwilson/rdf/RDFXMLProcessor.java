package com.garretwilson.rdf;

import java.net.*;
import java.util.*;

import com.garretwilson.model.Resource;
import com.garretwilson.net.*;
import com.garretwilson.text.xml.XMLBase;
import com.garretwilson.text.xml.XMLUtilities;
import com.garretwilson.text.xml.XMLConstants;
import com.garretwilson.util.Debug;
import com.garretwilson.util.LocaleUtilities;
import org.w3c.dom.*;

/**Class that is able to construct an RDF data model from an XML-based
	RDF serialization. Each instance of an RDF processor maintains an internal
	RDF data model throughout its lifetime that is continually updated with
	every new RDF processing that occurs.
	<p>The RDF processor maintains RDF data in two separate formats: the RDF
	data model <code>RDF</code>, as well as a list of statements used to create
	the data model. The RDF data model may be replaced and its members modified,
	but these actions will not update the list of RDF statements. The RDF
	statements are only generated by the RDF processor itself as it parses
	RDF serializations, and are available to give information on the parser
	actions.</p>
	TODO If a property from a non-RDF namespace has (for example) a "resource" attribute (i.e. a property with no namespace), property resources are not correctly created and can cause endless loops when trying to analyze the namespace
@author Garret Wilson
*/
public class RDFXMLProcessor extends AbstractRDFProcessor implements RDFConstants, RDFXMLConstants
{

	//constants for parseAttributeProperties()
	/**An attribute in the context of a resource description (<code>&lt;rdf:Description&gt;</code>).*/
	protected static final int DESCRIPTION_CONTEXT=1;
	/**An attribute in the context of a resource reference (<code>reference="&hellip;"</code>).*/
	protected static final int REFERENCE_CONTEXT=2;
	/**An attribute in the context of a property reference with only attributes and no children.*/
	protected static final int EMPTY_PROPERTY_CONTEXT=3;
	/**An attribute in the context of a reference short form (<code>parse=Type"Resource"</code>).*/
	protected static final int PROPERTY_AND_NODE_CONTEXT=4;

	/**Default constructor.*/
	public RDFXMLProcessor()
	{
		super();  //construct parent base class
	}

	/**Constructor that specifies an existing data model to continue filling.
	@param newRDF The RDF data model to use.
	*/
	public RDFXMLProcessor(final RDF newRDF)
	{
		super(newRDF);  //construct the parent class
	}

	/**Processes RDF serialized in an XML document. Processes data contained in
		every <code>&lt;rdf:RDF&gt;</code> data island.
	@param document The XML document that might contain RDF data.
	@param baseURI The base URI, or <code>null</code> if the base URI is not
		known.
	@return The RDF data model resulting from this processing and any previous
		processing.
	@exception URISyntaxException Thrown if a URI is syntactically incorrect.
	*/
	public RDF processRDF(final Document document, final URI baseURI) throws URISyntaxException
	{
		setBaseURI(baseURI);  //set the base URI
		return processRDF(document); //process the data in the document
	}

	/**Processes RDF serialized in an XML document. Processes data contained in
		every <code>&lt;rdf:RDF&gt;</code> data island. Whatever base URI has been
		set is unchanged.
	@param document The XML document that might contain RDF data.
	@return The RDF data model resulting from this processing and any previous
		processing.
	@exception URISyntaxException Thrown if a URI is syntactically incorrect.
	*/
	public RDF processRDF(final Document document) throws URISyntaxException
	{
		return processRDF(document.getDocumentElement()); //process the data in the document element
	}

	/**Processes RDF serialized in an XML document. Searches the given element and
		all its children, processing data contained in every
		<code>&lt;rdf:RDF&gt;</code> data island.
	@param element The XML element that might contain RDF data.
	@param baseURI The base URI, or <code>null</code> if the base URI is not
		known.
	@return The RDF data model resulting from this processing and any previous
		processing.
	@exception URISyntaxException Thrown if a URI is syntactically incorrect.
	*/
	public RDF processRDF(final Element element, final URI baseURI) throws URISyntaxException
	{
		setBaseURI(baseURI);  //set the base URI
		return processRDF(element);	//process the element 
	}

	/**Processes RDF serialized in an XML document. Searches the given element
		and all its children, processing data contained in every
		<code>&lt;rdf:RDF&gt;</code> data island. Whatever base URI has been
		set is unchanged.
	@param element The XML element that might contain RDF data.
	@return The RDF data model resulting from this processing and any previous
		processing.
	@exception URISyntaxException Thrown if a URI is syntactically incorrect.
	*/
	public RDF processRDF(final Element element) throws URISyntaxException
	{
		reset();	//make sure we don't have temporary data left over from last time
		processRDFIslands(element);	//process any internal RDF islands
		createResources();	//create all proxied resources in the statements we gathered
		processStatements();	//process all the statements and assign resources to properties
		reset();	//release all our references temporary resource proxies
		return getRDF();  //return the RDF data collected
	}

	/**Processes an RDF resource serialized in the provided XML document.
	Whatever base URI has been set is unchanged.
	@param element The XML element that might contain RDF data.
	@return The RDF data model resulting from this processing and any previous processing.
	@exception URISyntaxException Thrown if a URI is syntactically incorrect.
	*/
	public RDFResource processRDFResource(final Element element) throws URISyntaxException
	{
		reset();	//make sure we don't have temporary data left over from last time
		final Resource resource=processResource(element);	//process the given RDF resource
		final RDFResource rdfResource=createResources(resource);	//create all proxied resources in the statements we gathered, and get the RDF resource the element represents
		processStatements();	//process all the statements and assign resources to properties
		reset();	//release all our references temporary resource proxies
		return rdfResource;  //return the RDF resource the element represents
}

	/**Processes RDF serialized in an XML document. Searches the given element
		and all its children, processing data contained in every
		<code>&lt;rdf:RDF&gt;</code> data island. Whatever base URI has been
		set is unchanged.
	@param element The XML element that might contain RDF data.
	@return The RDF data model resulting from this processing and any previous
		processing.
	@exception URISyntaxException Thrown if a URI is syntactically incorrect.
	*/
	protected void processRDFIslands(final Element element) throws URISyntaxException
	{
		if(RDF_NAMESPACE_URI.toString().equals(element.getNamespaceURI()) //if this element is in the RDF namespace G***fix better
			  && ELEMENT_RDF.equals(element.getLocalName())) //if this element indicates that the children are RDF
		{
			final NodeList childNodeList=element.getChildNodes(); //get a list of child nodes
			for(int i=0; i<childNodeList.getLength(); ++i)  //look at each child node
			{
				final Node childNode=childNodeList.item(i); //get a reference to this child node
				if(childNode.getNodeType()==Node.ELEMENT_NODE) //if this is an element
				{
					processResource((Element)childNode);  //parse the contents of the RDF container element
				}
			}
		}
		else  //if this is a normal, non-RDF node
		{
			final NodeList childNodeList=element.getChildNodes(); //get a list of child nodes
			for(int i=0; i<childNodeList.getLength(); ++i)  //look at each child node
			{
				final Node childNode=childNodeList.item(i); //get a reference to this child node
				if(childNode.getNodeType()==Node.ELEMENT_NODE) //if this is an element
				{
					processRDFIslands((Element)childNode);  //parse the contents of the element, not knowing if this is an RDF element or not
				}
			}
		}
	}

	/**Processes the given element as representing an RDF resource.
	@param element The XML element that represents the RDF resource.
	@return An object identifying the resource the XML element represents.
	@exception URISyntaxException Thrown if a URI is syntactically incorrect.
	*/
	protected Resource processResource(final Element element) throws URISyntaxException
	{
		final URI elementNamespaceURI=element.getNamespaceURI()!=null ? new URI(element.getNamespaceURI()) : null; //get the element's namespace, or null if the element has no namespace
		final String elementLocalName=element.getLocalName(); //get the element's local name
//G***del Debug.trace("processing resource with XML element namespace: ", elementNamespaceURI); //G***del
//G***del Debug.trace("processing resource with XML local name: ", elementLocalName); //G***del
		//G***what do we do if <rdf:RDF> occurs inside <rdf:RDF>?
		final String referenceURIValue=getRDFAttribute(element, ATTRIBUTE_ABOUT); //get the reference URI attribute value, if there is one
		final String nodeIDValue=getRDFAttribute(element, ATTRIBUTE_NODE_ID);	//get the node ID attribute value, if there is one
		final String anchorID=getRDFAttribute(element, ATTRIBUTE_ID); //get the anchor ID if there is one
	  assert referenceURIValue==null || anchorID==null : "Resource cannot have both reference URI "+referenceURIValue+" and anchor ID "+anchorID+"."; //TODO change to an actual RDF error
		assert referenceURIValue==null || nodeIDValue==null : "Resource cannot have both reference URI "+referenceURIValue+" and node ID "+nodeIDValue+"."; //TODO change to an actual RDF error
		final URI referenceURI;  //we'll determine the reference URI from the rdf:about or rdf:ID attribute
		if(referenceURIValue!=null) //if there is a reference URI
		{
//G***del Debug.trace("found reference URI: ", referenceURIValue);  //G***del
//G***del				//G***we need to normalize the reference URI
			referenceURI=XMLBase.resolveURI(new URI(referenceURIValue), element, getBaseURI());  //resolve the reference URI to the base URI
		}
		else if(anchorID!=null)  //if there is an anchor ID
		{
//G***del Debug.trace("found anchor ID: ", anchorID);  //G***del
			referenceURI=new URI(XMLBase.getBaseURI(element, getBaseURI()).toString()+URIConstants.FRAGMENT_SEPARATOR+anchorID);  //create a reference URI from the document base URI and the anchor ID	//G***make better with new URI methods
		}
		else  //if there is neither a resource ID nor an anchor ID
		{
			referenceURI=null;  //this is a blank node
		}
//G***del Debug.trace("resulting reference URI: ", referenceURI);  //G***del
		final Resource resource;	//we'll create either an RDF resource, if we know the type, or a proxy for the resource
		if(referenceURI!=null)	//if we have a reference URI for the resouce
		{
			resource=getResourceProxy(referenceURI);	//create a resource proxy from the reference URI, or use one already available for the reference URI
		}
		else	//if there is no reference URI
		{
			resource=getResourceProxy(nodeIDValue!=null ? nodeIDValue : generateNodeID());	//retrieve or create a resource proxy from the node ID, generating our own node ID if there was none given			
		}
			//if this is not an <rdf:Description> element, the element name gives its type, so add that type to the resource
		if(!RDF_NAMESPACE_URI.equals(elementNamespaceURI) || !ELEMENT_DESCRIPTION.equals(elementLocalName)) 
		{
			final RDFResource typeProperty=getRDF().locateResource(RDF_NAMESPACE_URI, TYPE_PROPERTY_NAME); //get an rdf:type resource
			final RDFResource typePropertyValue=getRDF().locateResource(elementNamespaceURI, elementLocalName);	//locate the resource representing the type value
				//add a statement in the form, {resource proxy, rdf:type resource, type value resource}
			addStatement(new DefaultStatement(resource, typeProperty, typePropertyValue));
		}
/*G***maybe later allow some way to show preferences for types, in case multiple types are given that all have resource factories, but that may not be necessary; if not, delete
			//if this is not an <rdf:Description> element, the element name gives its type, so we can go ahead and create the resource
		if(!RDF_NAMESPACE_URI.equals(elementNamespaceURI) || !ELEMENT_DESCRIPTION.equals(elementLocalName)) 
		{
			  //get or create a new resource with the given reference URI and type;
				//  this allows a resource factory to create the appropriate type of
				//  resource object
			resource=getRDF().locateTypedResource(referenceURI, elementNamespaceURI, elementLocalName);


				//G***this next line is necessary if we create the resource now but a later reference tries to link to it
			putProxiedRDFResource(resourceProxy, resource);	//associate the resource with the resource proxy so we won't have to go through all this the next time 


			final RDFResource typeProperty=getRDF().locateResource(RDF_NAMESPACE_URI, TYPE_PROPERTY_NAME); //get an rdf:type resource
			final RDFResource typePropertyValue=getRDF().locateResource(elementNamespaceURI, elementLocalName);	//locate the resource representing the type value
				//add a statement in the form, {resource proxy, rdf:type resource, type value resource}
			addStatement(new DefaultStatement(resource, typeProperty, typePropertyValue));
		}
		else	//if an express type isn't given as the element name
		{
*/
		processAttributeProperties(resource, element, DESCRIPTION_CONTEXT);  //parse the attributes for the resource description
		processChildElementProperties(resource, element);	//parse the child elements as properties
		return resource;  //return the resource or resource proxy we created
	}

	/**Parses the child elements of the given element and assign them as
	  properties to the given resource.
	@param resource The object that represents the resource to which
		child element properties should be added.
	@param element The element that contains the attributes to be considered
		properties.
	@exception URISyntaxException Thrown if a URI is syntactically incorrect.
	*/
	protected void processChildElementProperties(final Resource resource, final Element element) throws URISyntaxException
	{
		int memberCount=0; //show that we haven't found any container members, yet
		final NodeList childNodeList=element.getChildNodes(); //get a list of child nodes
		for(int i=0; i<childNodeList.getLength(); ++i)  //look at each child node
		{
			final Node childNode=childNodeList.item(i); //get a reference to this child node
			if(childNode.getNodeType()==Node.ELEMENT_NODE) //if this is an element
			{
				final Resource property=processProperty(resource, (Element)childNode, memberCount);  //parse the element representing an RDF property
					//if this is an rdf:_X property (originally serialized as rdf:li)
				if(RDFUtilities.isContainerMemberPropertyReference(property.getReferenceURI()))
				{
					++memberCount;  //show that we have another member
				}
			}
		}
	}

	/**Parses the attributes of the given element and assign them as properties
	  to the given resource. Special RDF properties such as <code>rdf:about</code>
		are ignored.
	@param resource The object that represents the resource to which attribute
		properties should be added.
	@param element The element that contains the attributes to be considered
		properties.
	@param context The context, <code>DESCRIPTION_CONTEXT</code>,
		<code>REFERENCE_CONTEXT</code>, <code>PROPERTY_AND_NODE_CONTEXT</code>,
		or <code>EMPTY_PROPERTY_CONTEXT</code>, describing whether the attributes
		are part of a resource description, a resource reference, or a reference to
		a blank node resource in short form, or the creation of a blank node from
		an empty property element, respectively.
	@exception URISyntaxException Thrown if an RDF URI is syntactically incorrect.
	*/
	protected void processAttributeProperties(final Resource resource, final Element element, final int context) throws URISyntaxException
	{
		final URI elementNamespaceURI=element.getNamespaceURI()!=null ? new URI(element.getNamespaceURI()) : null; //get the element's namespace, or null if there is no namespace URI
		final NamedNodeMap attributeNodeMap=element.getAttributes();  //get a map of the attributes
		for(int i=attributeNodeMap.getLength()-1; i>=0; --i)  //look at each of the attributes
		{
			final Attr attribute=(Attr)attributeNodeMap.item(i);  //get a reference to this attribute
		  final URI attributeNamespaceURI=attribute.getNamespaceURI()!=null ? new URI(attribute.getNamespaceURI()) : null; //get the attribute's namespace URI, or null if it has no namespace URI
			final String attributePrefix=attribute.getPrefix(); //get the attribute's prefix
		  final String attributeLocalName=attribute.getLocalName(); //get the attribute's local name
		  final String attributeValue=attribute.getValue(); //get the attribute's value
/*G***del
Debug.trace("processing attribute from namespace: ", attributeNamespaceURI);
Debug.trace("processing attribute from local name: ", attributeLocalName);
Debug.trace("processing attribute from value: ", attributeValue);
*/
				//ignore attributes with the "xmlns" prefix or in the xmlns namespace
			if(XMLConstants.XMLNS_NAMESPACE_PREFIX.equals(attributePrefix) || XMLConstants.XMLNS_NAMESPACE_URI.equals(attributeNamespaceURI))
			{
				continue;
			}
				//process attributes with the "xml" prefix (or in the xml namespace) specially
			else if(XMLConstants.XML_NAMESPACE_PREFIX.equals(attributePrefix) || XMLConstants.XML_NAMESPACE_URI.equals(attributeNamespaceURI))
			{
					//TODO add support for xml:lang
				continue;
			}
			  //ignore the rdf:about attribute in descriptions, disallow it in references
			else if(isRDFAttribute(ATTRIBUTE_ABOUT, elementNamespaceURI, attributeNamespaceURI, attributeLocalName))
			{
				switch(context)	//only allow this attribute in certain contexts
				{
					case REFERENCE_CONTEXT:	//rdf:about isn't allowed in a reference
					case EMPTY_PROPERTY_CONTEXT:	//rdf:about isn't allowed in an empty property element
					case PROPERTY_AND_NODE_CONTEXT: 	//rdf:about isn't allowed in parseType="Resource"
						Debug.error("rdf:about attribute is not allowed in a resource reference."); //TODO fix with real exceptions
						return;
					case DESCRIPTION_CONTEXT:	//ignore rdf:about in descriptions
					default:
						continue;
				}
			}
			  //ignore the rdf:ID attribute in descriptions, disallow it in references
			else if(isRDFAttribute(ATTRIBUTE_ID, elementNamespaceURI, attributeNamespaceURI, attributeLocalName))
			{
				switch(context)	//only allow this attribute in certain contexts
				{
					case REFERENCE_CONTEXT:	//rdf:ID isn't allowed in a reference
					case EMPTY_PROPERTY_CONTEXT:	//rdf:ID isn't allowed in an empty property element
					case PROPERTY_AND_NODE_CONTEXT: 	//rdf:ID isn't allowed in parseType="Resource"
						Debug.error("rdf:ID attribute is not allowed in a resource reference."); //TODO fix with real exceptions
						return;
					case DESCRIPTION_CONTEXT:	//ignore rdf:ID in descriptions
					default:
						continue;
				}
			}
				//ignore the rdf:nodeID attribute in descriptions and references
			else if(isRDFAttribute(ATTRIBUTE_NODE_ID, elementNamespaceURI, attributeNamespaceURI, attributeLocalName))
			{
				switch(context)	//only allow this attribute in certain contexts
				{
					case PROPERTY_AND_NODE_CONTEXT: 	//rdf:nodeID isn't allowed in parseType="Resource" G***make sure this is correct
						Debug.error("rdf:nodeID attribute is not allowed in blank node reference short form."); //TODO fix with real exceptions
						return;
					case REFERENCE_CONTEXT:	//ignore rdf:nodeID in references
					case EMPTY_PROPERTY_CONTEXT:	//ignore rdf:nodeID in empty property elements G***make sure this is correct
					case DESCRIPTION_CONTEXT:	//ignore rdf:nodeID in descriptions
					default:
						continue;
				}
			}
			  //ignore the rdf:parseType attribute in references, disallow it in descriptions
			else if(isRDFAttribute(ATTRIBUTE_PARSE_TYPE, elementNamespaceURI, attributeNamespaceURI, attributeLocalName))
			{
				switch(context)	//only allow this attribute in certain contexts
				{
					case DESCRIPTION_CONTEXT:	//rdf:parseType isn't allowed in a description
					case REFERENCE_CONTEXT:	//rdf:parseType isn't allowed in references
					case EMPTY_PROPERTY_CONTEXT:	//rdf:parseType isn't allowed in an empty property element
						Debug.error("rdf:parseType attribute is not allowed in a resource description."); //TODO fix with real exceptions
						return;
					case PROPERTY_AND_NODE_CONTEXT: 	//ignore rdf:parseType in the property-and-node context (that's the attribute that defined this context, after all)
					default:
						continue;
				}
			}
			  //ignore the rdf:resource attribute in reference, disallow it in descriptions
			else if(isRDFAttribute(ATTRIBUTE_RESOURCE, elementNamespaceURI, attributeNamespaceURI, attributeLocalName))
			{
				switch(context)	//only allow this attribute in certain contexts
				{
					case DESCRIPTION_CONTEXT:	//rdf:resource isn't allowed in descriptions
					case EMPTY_PROPERTY_CONTEXT:	//rdf:resource isn't allowed in an empty property element
					case PROPERTY_AND_NODE_CONTEXT: 	//rdf:ID isn't allowed in parseType="Resource"
						Debug.error("rdf:resource attribute is not allowed in a resource reference."); //TODO fix with real exceptions
						return;
					case REFERENCE_CONTEXT:	//rdf:resource isn't allowed in a reference
					default:
						continue;
				}
			}
			else	//for all other attributes
			{
				switch(context)	//only allow this attribute in certain contexts
				{
					case REFERENCE_CONTEXT:	//normal attributes are allowed for a normal reference
					case PROPERTY_AND_NODE_CONTEXT: 	//normal attributes isn't allowed in the parseType="Resource" context
						Debug.error(attribute.getName()+" attribute is not allowed in a property-and-node context."); //TODO fix with real exceptions
						return;
					default:
						{
							final RDFResource property=getRDF().locateResource(attributeNamespaceURI, attributeLocalName);	//locate a resource for this attribute property
							final RDFLiteral objectLiteral=new RDFPlainLiteral(attributeValue);	//create a literal for the object							
								//add a statement in the form, {resource, property, object literal}
							addStatement(new DefaultStatement(resource, property, objectLiteral));
						}
						break;
				}
			}
		}
	}

	/**Processes the given element as representing an RDF property.
	@param resource The object that represents the resource to which the property
		should be added.
	@param element The XML element that represents the RDF property.
	@param memberCount The number of container member items (represented by
		<code>rdf:li</code>) the resource already contains.
	@return The resource that represents the processed property, the predicate
		of the added statement.
	@exception URISyntaxException Thrown if an RDF URI is syntactically incorrect.
	*/
	protected Resource processProperty(final Resource resource, final Element element, final int memberCount) throws URISyntaxException
	{
		final URI elementNamespaceURI=element.getNamespaceURI()!=null ? new URI(element.getNamespaceURI()) : null; //get the element's namespace, or null if there is no namespace URI
		final String elementLocalName=element.getLocalName(); //get the element's local name
//G***del Debug.trace("processing property with XML element namespace: ", elementNamespaceURI); //G***del
//G***del Debug.trace("processing property with XML local name: ", elementLocalName); //G***del
		final String propertyLocalName;	//if this is an rdf:li property, we'll convert it to rdf_X, where X represents the member count plus one	
		if(RDF_NAMESPACE_URI.equals(elementNamespaceURI) && LI_PROPERTY_REFERENCE_URI.equals(elementLocalName)) //if this is an rdf:li property
		{
			propertyLocalName=CONTAINER_MEMBER_PREFIX+(memberCount+1); //create a local name in the form "_X", where X is the member count plus one
		}
		else	//if this is *not* an rdf:li property, it's a normal property
		{
			propertyLocalName=elementLocalName;	//use the element's local name normally in forming the property reference URI
		}
		final RDFResource propertyResource=getRDF().locateResource(elementNamespaceURI, propertyLocalName); //get a resource from the element name
		final Object propertyValue;  //we'll assign the property value to this variable---either a resource or a literal
		final String parseType=getRDFAttribute(element, ATTRIBUTE_PARSE_TYPE); //get the parse type, if there is one
		if(COLLECTION_PARSE_TYPE.equals(parseType))	//if this is a collection
		{
			//G***we should make sure there are no other attributes
			Resource firstItemListResource=null;	//we haven't created the first item list resource, yet
			Resource lastItemListResource=null;	//we haven't created the last item list resource, yet
			final RDFResource typeProperty=getRDF().locateResource(RDF_NAMESPACE_URI, TYPE_PROPERTY_NAME); //get an rdf:type resource
			final RDFResource listClassResource=getRDF().locateResource(RDF_NAMESPACE_URI, LIST_CLASS_NAME);	//locate the resource representing the rdf:list class
				//parse the child elements
			final NodeList childNodeList=element.getChildNodes(); //get a list of child nodes
			for(int i=0; i<childNodeList.getLength(); ++i)  //look at each child node
			{
				final Node childNode=childNodeList.item(i); //get a reference to this child node
				if(childNode.getNodeType()==Node.ELEMENT_NODE) //if this is an element
				{
					final Resource elementValue=processResource((Element)childNode); //process the child element as an RDF resource
					final Resource listResource=getResourceProxy(generateNodeID());	//create a new list resource proxy to represent this item in the collection
						//add a statement in the form, {list, rdf:type, rdf:list}
					addStatement(new DefaultStatement(listResource, typeProperty, listClassResource));
					final Resource firstProperty=getRDF().locateResource(RDF_NAMESPACE_URI, FIRST_PROPERTY_NAME);	//get a resource representing the rdf:first property
						//add a statement setting the list's rdf:first property to the new element
					addStatement(new DefaultStatement(listResource, firstProperty, elementValue));
					if(firstItemListResource==null)	//if this is the first list item
					{
						firstItemListResource=listResource;	//show that we just created a list resource
					}
					else if(lastItemListResource!=null)	//if this is not the first item, there should have been a previous list item (this check is redundant)
					{
						final Resource restProperty=getRDF().locateResource(RDF_NAMESPACE_URI, REST_PROPERTY_NAME);	//get a resource representing the rdf:rest property
							//add a statement setting the previous list's rdf:rest property to the new list
						addStatement(new DefaultStatement(lastItemListResource, restProperty, listResource));
					}
					lastItemListResource=listResource;	//save this list resource for the next time around, in case there are other list items
				}
			}
			final RDFListResource nilListResource=new RDFListResource(NIL_RESOURCE_URI);	//create a list resource representing the rdf:nil resource; don't use an existing rdf:nil list resource, because the reference URI may need to change when the list is modified				
				//add a statement in the form, {nil list, rdf:type, rdf:list}
			addStatement(new DefaultStatement(nilListResource, typeProperty, listClassResource));
			if(lastItemListResource!=null)	//if there was a last item
			{
				final Resource restProperty=getRDF().locateResource(RDF_NAMESPACE_URI, REST_PROPERTY_NAME);	//get a resource representing the rdf:rest property
					//add a statement setting the last list's rdf:rest property to the the rdf:nil list
				addStatement(new DefaultStatement(lastItemListResource, restProperty, nilListResource));
			}
			else if(firstItemListResource==null)	//if we didn't create any list items (logically this check is redundant, because if there is no last resource there is also no first resource)
			{
				firstItemListResource=nilListResource;	//the first list item is the rdf:nil list, because there list contained no items
			}
			propertyValue=firstItemListResource;	//the first list item will be the first list item, whether it is a node representing a resource or the rdf:nil list we created for an empty list
		}
		else if(RESOURCE_PARSE_TYPE.equals(parseType))	//if this is a resource as a property-and-node
		{
			propertyValue=getResourceProxy(generateNodeID());	//retrieve or create a new resource proxy with our own generated node ID, as the node is completely anonymous			
			processAttributeProperties((Resource)propertyValue, element, PROPERTY_AND_NODE_CONTEXT);  //parse the property attributes, which will simply create errors if there are any unexpected attributes
			processChildElementProperties((Resource)propertyValue, element);	//parse the child elements as properties
		}
		else if(LITERAL_PARSE_TYPE.equals(parseType))	//if this is an XMLLiteral
		{
			//TODO process the attributes to make sure there are no unexpected attributes
			final Document document=XMLUtilities.createDocument(element);	//create a new document from a copy of the given element
			//G***do we want to ensure namespace declarations?
			final Element documentElement=document.getDocumentElement();	//get a reference to the document element
			final DocumentFragment documentFragment=XMLUtilities.extractChildren(documentElement);	//extract the children of the document element to a document fragment TODO important probably reset the owner document, so that this won't keep the entire original document tree around
			propertyValue=new RDFXMLLiteral(documentFragment);	//create an XML literal containing the document fragment, which now contains a copy of the information of the XML tree below the given element
		}
		else	//by default assume that we're parsing a resource as the property value
		{
			final String referenceURIValue=getRDFAttribute(element, ATTRIBUTE_RESOURCE); //get the reference URI of the referenced resource, if there is one
			final String nodeIDValue=getRDFAttribute(element, ATTRIBUTE_NODE_ID);	//get the node ID attribute value, if there is one
			assert referenceURIValue==null || nodeIDValue==null : "Resource cannot have both reference URI "+referenceURIValue+" and node ID "+nodeIDValue+"."; //TODO change to an actual RDF error
	//G***del Debug.trace("RDF attribute: ", referenceURIValue);  //G***del
			if(referenceURIValue!=null || nodeIDValue!=null) //if there is a reference URI or a node ID, this is a reference to another node
			{
				final ResourceProxy resourceProxy;	//we'll create a stand-in object for the resource
				if(referenceURIValue!=null)	//if we have a reference URI for the resouce
				{
					final URI referenceURI=XMLBase.resolveURI(referenceURIValue, element, getBaseURI());  //resolve the reference URI to the base URI
					propertyValue=getResourceProxy(referenceURI);	//create a resource proxy from the reference URI, or use one already available for the reference URI
				}
				else	//if there is no reference URI
				{
					propertyValue=getResourceProxy(nodeIDValue!=null ? nodeIDValue : generateNodeID());	//retrieve or create a resource proxy from the node ID, generating our own node ID if there was none given			
				}
				processAttributeProperties((Resource)propertyValue, element, REFERENCE_CONTEXT);  //parse the property attributes, assigning them to the property value
			}
			else if(element.getChildNodes().getLength()==0) //if there are no child elements, this is a blank node
			{
//G***make sure this works when we implement node IDs			  final RDFResource propertyValueResource=getRDF().locateResource(getRDF().createAnonymousReferenceURI());  //get or create a resource from a generated anonymous reference URI
				propertyValue=getResourceProxy(generateNodeID());	//retrieve or create a new resource proxy with our own generated node ID, as the node is completely anonymous			
				processAttributeProperties((Resource)propertyValue, element, EMPTY_PROPERTY_CONTEXT);  //parse the property attributes, assigning them to the property value
			}
			else  //if there is no reference URI, there is either a normal property description below, or a literal
			{
				//G***we should make sure there are no attributes
				Element childElement=null; //show that we haven't found any child elements, yet
					//parse the child elements
				final NodeList childNodeList=element.getChildNodes(); //get a list of child nodes
				for(int i=0; i<childNodeList.getLength(); ++i)  //look at each child node
				{
					final Node childNode=childNodeList.item(i); //get a reference to this child node
					if(childNode.getNodeType()==Node.ELEMENT_NODE) //if this is an element
					{
						if(childElement==null)  //if we haven't already found a child element
						{
							childElement=(Element)childNode;  //cast the child node to an element
						}
						else if(childElement!=null)  //if we've already found a child element
						{
							Debug.warn("Only one property value allowed for "+propertyResource); //G***fix with real error handling
						}
					}
				}
				if(childElement!=null)  //if we found a child element for the property value
				{
					propertyValue=processResource(childElement); //process the child element as an RDF resource, the value of the property in this case
				}
				else  //if we didn't find any child elements, the content is a literal
				{
					final String childText=XMLUtilities.getText(element, true);	//retrieve the child text
					final String datatype=getRDFAttribute(element, ATTRIBUTE_DATATYPE); //get the datatype, if there is one TODO check elsewhere to make sure a datatype isn't given for non-literal content
					if(datatype!=null)	//if a datatype is present
					{
						propertyValue=getRDF().createTypedLiteral(childText, new URI(datatype));	//create a typed literal from the typed literal text
					}
					else	//if a datatype is not present, this is a plain literal
					{
							//get the xml:lang language tag, if there is one
						final String languageTag=XMLUtilities.getDefinedAttributeNS(element, XMLConstants.XML_NAMESPACE_URI.toString(), XMLConstants.ATTRIBUTE_LANG);
							//create a locale for the language if there is a language tag
						final Locale languageLocale=languageTag!=null ? LocaleUtilities.createLocale(languageTag) : null;
						propertyValue=new RDFPlainLiteral(childText, languageLocale);  //create a literal from the element's text, noting the specified language if any
					}
				}
			}
		}
		if(propertyValue instanceof Resource)	//if we found a resource for the property value
		{
				//add a statement in the form, {resource/resource proxy, property resource, resource/resource proxy value}
			addStatement(new DefaultStatement(resource, propertyResource, (Resource)propertyValue));
		}
		else if(propertyValue instanceof RDFLiteral)	//if we found a literal value for the property value
		{
				//add a statement in the form, {resource/resource proxy, property resource, literal value}
			addStatement(new DefaultStatement(resource, propertyResource, (RDFLiteral)propertyValue));
		}
		else	//we should only have found a resource (or resource proxy) or a literal
		{
			throw new AssertionError("Logical error: expected resource or literal for object, somehow created "+propertyValue.getClass());
		}
		return propertyResource;	//return the resource that represents the property we processed
	}

	/**Determines if an element attribute is an RDF attribute, recognizing
		either prefixed or non-prefixed attributes.
	@param rdfAttributeLocalName The RDF attribute name to check for. 
	@param elementNamespaceURI The namespace of the element to which the
		attribute belongs.
	@param attributeNamespaceURI namespace of the RDF attribute.
	@param attributeLocalName The local name of the RDF attribute.
	@return <code>true</code> if this is the specified RDF attribute.
	*/
	protected boolean isRDFAttribute(final String rdfAttributeLocalName, final URI elementNamespaceURI, final URI attributeNamespaceURI, final String attributeLocalName)
	{
		if(rdfAttributeLocalName.equals(attributeLocalName))	//if the attribute has the correct local name
		{
			if(RDF_NAMESPACE_URI.equals(attributeNamespaceURI) || (attributeNamespaceURI==null && RDF_NAMESPACE_URI.equals(elementNamespaceURI)))
			{
				return true;	//show that this is the expected RDF attribute
			}
		}
		return false;	//show that this attribute is not the RDF attribute expected
	}

	/**Retrieves an RDF attribute from an element, if it exists, recognizing
		either prefixed or non-prefixed attributes. If the non-prefixed form is
		used, a warning is generated.
		It is assumed that this method will only be called once for a particular
		attribute, as each call could produce another warning.
	@param element The element being checked for attributes.
	@param attributeLocalName The local name of the RDF attribute to check for.
	@return The specified RDF attribute.
	*/
	protected String getRDFAttribute(final Element element, final String attributeLocalName)
	{
		if(element.hasAttributeNS(RDF_NAMESPACE_URI.toString(), attributeLocalName))  //if there is a prefixed attribute value
		{
		  return element.getAttributeNS(RDF_NAMESPACE_URI.toString(), attributeLocalName); //get the prefixed attribute value
		}
		else if(element.getNamespaceURI()!=null && element.getNamespaceURI().equals(RDF_NAMESPACE_URI.toString()) && element.hasAttributeNS(null, attributeLocalName)) //if there is a non-prefixed attribute value
		{
			Debug.warn("Non-prefixed rdf:"+attributeLocalName+" attribute deprecated."); //G***put in a real warning
		  return element.getAttributeNS(null, attributeLocalName); //return the non-prefixed attribute value
		}
		else  //if neither attribute is available
			return null;  //show that the RDF attribute is not available
	}

}